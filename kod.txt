





/*////////////////////////////////////////
* Nazwa pliku: konfiguracja.hpp
* Projekt:     MSL - Ekspansja
* Autor:       Dominik Majak
*/////////////////////////////////////////


#ifndef KONFIGURACJA_HPP
#define KONFIGURACJA_HPP


// sciezki
#define SCIEZKA_DANE_WEJSCIOWE                  "dane/dane_wejsciowe_1.txt"
#define SCIEZKA_LOGGER                          "log/log_przetwarzanie.txt"

// flagi Loggera
#define WLACZ_LOGGER_MACIERZY_BLOKUJACYCH       1
#define WLACZ_LOGGER_POKRYC                     1


#endif





/*////////////////////////////////////////
* Nazwa pliku: logger.hpp
* Projekt:     MSL - Ekspansja
* Autor:       Dominik Majak
*/////////////////////////////////////////


#ifndef LOGGER_HPP
#define LOGGER_HPP


#include <fstream>
#include <mutex>
#include <string>


class Logger
{
public:
    static void inicjalizuj (
        const std::string& sciezka = "log/log_przetwarzanie.txt", // domyslna sciezka: log/log_przetwarzanie.txt
        bool truncate = true // truncate==true — nadpisuje log przy starcie
    );

    // zapisz log w jednej linii
    static void info (
        const std::string& lina
    );

    // zamknij plik
    static void close();

    // dostęp do strumienia (np. do <<)
    static std::ofstream& stream();

private:
    static std::ofstream plik; // uchwyt do pliku
    static std::mutex mtx; // mutex do blokowania dostepu do zasobow w czasie zapisywania
};


#endif





/*////////////////////////////////////////
* Nazwa pliku: logger.cpp
* Projekt:     MSL - Ekspansja
* Autor:       Dominik Majak
*/////////////////////////////////////////


#include "logger.hpp"
#include <filesystem>


std::ofstream Logger::plik;
std::mutex Logger::mtx;


void Logger::inicjalizuj (
    const std::string& sciezka,
    bool truncate
) {
    std::scoped_lock lock(mtx); // zablokuj dostep

    if ( !sciezka.empty()) // jezeli podano sciezke
    {
        auto s = std::filesystem::path(sciezka).parent_path();
        if (!s.empty())
            std::filesystem::create_directories( s); // utworz sciezke
    }

    if (plik.is_open())
        plik.close();

    std::ios::openmode tryb_otwarcia = std::ios::out;
    tryb_otwarcia |= truncate ? std::ios::trunc : std::ios::app; // wybierz jak otworzyc plik

    plik.open( sciezka, tryb_otwarcia);
}


void Logger::info (
    const std::string& lina
) {
    std::scoped_lock lock(mtx);

    if (plik.is_open())
    {
        plik << lina << '\n'; // zapisuj dane do bufora
        plik.flush(); // wymus zwolnienie bufora i zapisz dane
    }
}


void Logger::close()
{
    std::scoped_lock lock(mtx);

    if (plik.is_open())
        plik.close();
}


std::ofstream& Logger::stream()
{
    return plik;
}





/*////////////////////////////////////////
* Nazwa pliku: wyznaczenie_macierzy_blokujacych.hpp
* Projekt:     MSL - Ekspansja
* Autor:       Dominik Majak
*/////////////////////////////////////////


#ifndef WYZNACZANIE_MACIERZY_BLOKUJACYCH_HPP
#define WYZNACZANIE_MACIERZY_BLOKUJACYCH_HPP


#include <vector>
#include "kostka.hpp"


class WyznaczanieMacierzyBlokujacych
{
public:
    using MacierzBlokujaca = std::vector<std::vector<bool>>;

    static MacierzBlokujaca wyznacz_macierz_blokujaca(const Kostka& kostka, const ZbiorKostek& R);
};


#endif





/*////////////////////////////////////////
* Nazwa pliku: wyznaczenie_macierzy_blokujacych.cpp
* Projekt:     MSL - Ekspansja
* Autor:       Dominik Majak
*/////////////////////////////////////////


#include "wyznaczanie_macierzy_blokujacych.hpp"
#include "logger.hpp"
#include "konfiguracja.hpp"
#include <sstream>
#include <algorithm>
#include <string>


WyznaczanieMacierzyBlokujacych::MacierzBlokujaca WyznaczanieMacierzyBlokujacych::wyznacz_macierz_blokujaca(const Kostka& kostka, const ZbiorKostek& R)
{
    MacierzBlokujaca B;
    const std::size_t liczba_wierszy = R.rozmiar();
    const std::size_t liczba_kolumn = kostka.rozmiar();

    if (liczba_wierszy == 0)
    {
#if WLACZ_LOGGER_MACIERZY_BLOKUJACYCH
        Logger::info("Wyznaczanie macierzy blokującej: zbiór R jest pusty — macierz jest pusta.");
#endif
        return B;
    }

    B.assign(liczba_wierszy, std::vector<bool>(liczba_kolumn, false));
    for (std::size_t i = 0; i < liczba_wierszy; ++i)
    {
        const Kostka& r_kostka = R[i];
        if (r_kostka.rozmiar() != liczba_kolumn)
        {
#if WLACZ_LOGGER_MACIERZY_BLOKUJACYCH
            Logger::info("OSTRZEŻENIE: różna długość kostki w R[" + std::to_string(i) + "] niż kostki bazowej.");
#endif
        }

        const std::size_t wspolna_dlugosc = std::min(liczba_kolumn, r_kostka.rozmiar());
        for (std::size_t j = 0; j < wspolna_dlugosc; ++j)
        {
            const char k = kostka[j];
            const char r = r_kostka[j];
            if (k == '-' || r == '-') continue;
            if (k != r) B[i][j] = true;
        }
    }

#if WLACZ_LOGGER_MACIERZY_BLOKUJACYCH
    {
        std::ostringstream oss;
        oss << "Macierz blokująca dla kostki: " << kostka.pobierz_wartosc();
        Logger::info(oss.str());
        for (std::size_t i = 0; i < liczba_wierszy; ++i)
        {
            std::string wiersz;
            wiersz.reserve(liczba_kolumn);
            for (std::size_t j = 0; j < liczba_kolumn; ++j)
                wiersz += B[i][j] ? '1' : '0';
            Logger::info("R[" + std::to_string(i) + "] " + R[i].pobierz_wartosc() + " -> " + wiersz);
        }
    }
#endif

    return B;
}





/*////////////////////////////////////////
* Nazwa pliku: konwersja_formul.hpp
* Projekt:     MSL - Ekspansja
* Autor:       Dominik Majak
*/////////////////////////////////////////


#ifndef KONWERSJA_FORMUL_HPP
#define KONWERSJA_FORMUL_HPP


#include "kostka.hpp"
#include <vector>
#include <string>


class KonwersjaFormul
{
public:
    static std::string konwertuj_na_formule(const Kostka& kostka, const std::vector<std::string>& nazwy_wejsc);
};


#endif





/*////////////////////////////////////////
* Nazwa pliku: konwersja_formul.cpp
* Projekt:     MSL - Ekspansja
* Autor:       Dominik Majak
*/////////////////////////////////////////


#include "konwersja_formul.hpp"


std::string KonwersjaFormul::konwertuj_na_formule(const Kostka& kostka, const std::vector<std::string>& nazwy_wejsc)
{
    std::string formula;
    for (size_t i = 0; i < kostka.rozmiar(); ++i)
    {
        if (kostka[i] == '0') {
            formula += "~" + nazwy_wejsc[i] + " * ";
        } else if (kostka[i] == '1') {
            formula += nazwy_wejsc[i] + " * ";
        }
    }
    if (!formula.empty()) {
        formula = formula.substr(0, formula.size() - 3);
    }
    return formula;
}





/*////////////////////////////////////////
* Nazwa pliku: operacje_na_kostkach.hpp
* Projekt:     MSL - Ekspansja
* Autor:       Dominik Majak
*/////////////////////////////////////////


#ifndef OPERACJE_NA_KOSTKACH_HPP
#define OPERACJE_NA_KOSTKACH_HPP


#include "kostka.hpp"


// klasa pomocnicza do operacji logicznych na kostkach
class OperacjeNaKostkach
{
public:
    static bool czy_kostki_roznia_sie_o_jeden_bit(const Kostka& k1, const Kostka& k2);
    static Kostka lacz_kostki(const Kostka& k1, const Kostka& k2);
    static int liczba_jednynek_w_kostce(const Kostka& k);
    static bool czy_kostka_zawiera(const Kostka& wieksza, const Kostka& mniejsza);
    static bool czy_implikant_pokrywa_kostke(const Kostka& P, const Kostka& K);
};


#endif





/*////////////////////////////////////////
* Nazwa pliku: operacje_na_kostkach.cpp
* Projekt:     MSL - Ekspansja
* Autor:       Dominik Majak
*/////////////////////////////////////////


#include "operacje_na_kostkach.hpp"
#include <algorithm>


bool OperacjeNaKostkach::czy_kostki_roznia_sie_o_jeden_bit(const Kostka& k1, const Kostka& k2)
{
    if (k1.rozmiar() != k2.rozmiar()) return false;
    int roznice = 0;
    for (size_t i = 0; i < k1.rozmiar(); ++i)
    {
        if (k1[i] != k2[i])
        {
            if (k1[i] == '-' || k2[i] == '-') return false;
            roznice++;
            if (roznice > 1) return false;
        }
    }
    return roznice == 1;
}


Kostka OperacjeNaKostkach::lacz_kostki(const Kostka& k1, const Kostka& k2)
{
    std::string wynik = k1.pobierz_wartosc();
    for (size_t i = 0; i < k1.rozmiar(); ++i)
    {
        if (k1[i] != k2[i]) wynik[i] = '-';
    }
    return Kostka(wynik);
}


int OperacjeNaKostkach::liczba_jednynek_w_kostce(const Kostka& k)
{
    int licznik = 0;
    for (size_t i = 0; i < k.rozmiar(); ++i)
    {
        if (k[i] == '1') licznik++;
    }
    return licznik;
}


bool OperacjeNaKostkach::czy_kostka_zawiera(const Kostka& wieksza, const Kostka& mniejsza)
{
    if (wieksza.rozmiar() != mniejsza.rozmiar()) return false;
    for (size_t i = 0; i < wieksza.rozmiar(); ++i)
    {
        if (wieksza[i] != '-' && wieksza[i] != mniejsza[i]) return false;
    }
    return true;
}


bool OperacjeNaKostkach::czy_implikant_pokrywa_kostke(const Kostka& P, const Kostka& K)
{
    const std::size_t n = std::min(P.rozmiar(), K.rozmiar());
    for (std::size_t i = 0; i < n; ++i)
    {
        const char p = P[i];
        const char k = K[i];
        if (k == '-') {
            if (p != '-') return false;
        } else {
            if (!(p == '-' || p == k)) return false;
        }
    }
    for (std::size_t i = n; i < P.rozmiar(); ++i) {
        if (P[i] != '-') return false;
    }
    return true;
}